//排序算法；（algorithm）
// comparable接口；（在抽象比较中可以提供比较规则）基于java使用；
（（简单排序））；
冒泡排序；
// 比较相邻的两个元素；比较后两个可能要交换位置；一次会把最大的放到最后面；以此类推；一次次冒泡把大的放到后面；
// 性能分析（及分析算法在最坏情况下的性能）
// 及在排序最多次的·情况；
// （6 5 4 3 2 1）比较了n^2/2-n/2；交换了n^2/2-n/2次；执行了n^2-n；大o记（O（n^2））比较复杂了；
选择排序；
// 在剩余序列中选择想要的（最小的）元素放到合适位置；
// （假定最小值法）；
// 复杂度分析
// 比较+交换；（比较次数n^2/2-n/2；交换次数n^2/+n/2-1）
// 大O记（n^2）
插入排序
// like插入扑克牌
// step把数组分为已排序与为排序两组；
// 把未排序的第一个元素与已排序的元素历遍比较（要倒序比较）之后交换位置（插入）；（假定第一个元素已排序）
// 复杂度分析（最坏情况）逆序的情况；
// 比较+交换；（比较次数n^2/2-n/2；交换次数n^2/+n/2）
// O（n^2）只保留最高次项（小数据可用，大数据会指数级增长）
上述排序为简单排序，只能处理小数据类型，无法对大数据类型排序处理（或者说时间复杂度太大了）

（（高级排序））
希尔排序（插入排序的改良版本）
//假设一个增长量h=5（最大h的选取规则：先假定h=1；在h<数组长度/2时；while（h=2h+1）直到打破while'循环的那个数出现，这里是7；所以h最开始为7；减小规则为h=【h/2】取整；）
// ；按照h来将数据分组，h是几就总共分几组；而不是每组有h个；以第一个i开头，间隔n（h-1）个的数都分到一组；分完一组后以i+1为下一组开头；继续分知道最后一个元素被分到为止；
// 对分好的组（h=5）的数来进行插入排序；（得到一个较有序的数组）
// 再将h减小eg h=2；排列出来更有序；
// 再次减小h直到为1
// 再对全部进行插入排序
// 希尔排序优点：交换的次数比传统的插入排序次数少；时间复杂度远远减小
// 
// 
// 
//